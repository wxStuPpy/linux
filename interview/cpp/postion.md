在计算机程序的内存布局中，数据段、代码段、栈和堆是非常重要的概念，它们各自承担着不同的功能，下面为你详细介绍它们的特点和区别。

### 代码段（Code Segment）
#### 定义和用途
代码段也被称为文本段（Text Segment），它主要用于存储程序的可执行代码。这些代码是经过编译和链接后生成的机器指令，程序在运行时会按照代码段中的指令顺序依次执行。

#### 特点
- **只读**：通常情况下，代码段是只读的，这是为了防止程序在运行过程中意外修改自身的指令，从而保证程序的稳定性和安全性。
- **共享**：多个进程可以共享同一份代码段，例如多个用户同时运行同一个程序时，操作系统可以让这些进程共享该程序的代码段，以节省内存空间。
- **可执行**：代码段中的指令可以被 CPU 直接执行，是程序运行的核心部分。

#### 示例
以下是一个简单的 C 语言程序：
```c
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
```
经过编译后，`main` 函数以及 `printf` 等函数调用所对应的机器指令会被存储在代码段中。

### 数据段（Data Segment）
#### 定义和用途
数据段用于存储程序中已初始化的全局变量和静态变量。这些变量在程序启动时就会被分配内存，并且会被初始化为指定的值。

#### 特点
- **可读写**：数据段中的变量可以在程序运行过程中被修改，程序可以对这些变量进行读写操作。
- **持久化**：数据段中的变量在程序的整个生命周期内都存在，直到程序结束才会被释放。

#### 示例
```c
#include <stdio.h>

// 已初始化的全局变量
int global_variable = 10;

int main() {
    // 已初始化的静态变量
    static int static_variable = 20;
    printf("Global variable: %d\n", global_variable);
    printf("Static variable: %d\n", static_variable);
    return 0;
}
```
在这个示例中，`global_variable` 和 `static_variable` 会被存储在数据段中。

### 栈（Stack）
#### 定义和用途
栈是一种后进先出（LIFO）的数据结构，用于存储函数调用的上下文信息，包括局部变量、函数参数、返回地址等。每当调用一个函数时，系统会在栈上为该函数分配一块内存，称为栈帧，用于存储该函数的相关信息。当函数返回时，对应的栈帧会被销毁。

#### 特点
- **自动分配和释放**：栈上的内存由系统自动分配和释放，无需程序员手动管理。当函数调用结束时，栈上的内存会自动被回收。
- **空间有限**：栈的空间通常是有限的，如果在函数调用过程中栈空间耗尽，会导致栈溢出错误。
- **访问速度快**：由于栈的操作是按照后进先出的原则进行的，所以栈的访问速度非常快。

#### 示例
```c
#include <stdio.h>

void func(int a, int b) {
    int local_variable = a + b;
    printf("Local variable: %d\n", local_variable);
}

int main() {
    func(3, 5);
    return 0;
}
```
在调用 `func` 函数时，系统会在栈上为 `func` 函数分配一个栈帧，用于存储参数 `a`、`b` 和局部变量 `local_variable`。当 `func` 函数返回时，该栈帧会被销毁。

### 堆（Heap）
#### 定义和用途
堆是一块动态分配的内存区域，用于存储程序在运行过程中动态分配的内存。程序员可以使用 `malloc`、`calloc`、`realloc` 等函数在堆上分配内存，使用 `free` 函数释放内存。

#### 特点
- **动态分配和释放**：堆上的内存需要程序员手动分配和释放，如果程序员忘记释放内存，会导致内存泄漏。
- **空间较大**：堆的空间相对较大，可以满足程序对大量内存的需求。
- **访问速度较慢**：由于堆上的内存分配和释放是动态的，需要进行复杂的内存管理操作，所以堆的访问速度相对较慢。

#### 示例
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 在堆上分配内存
    int *ptr = (int *)malloc(sizeof(int));
    if (ptr == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }
    *ptr = 100;
    printf("Value in heap: %d\n", *ptr);
    // 释放堆上的内存
    free(ptr);
    return 0;
}
```
在这个示例中，使用 `malloc` 函数在堆上分配了一块内存，用于存储一个整数。在使用完这块内存后，使用 `free` 函数将其释放。

### 总结
| 区域 | 存储内容 | 读写特性 | 生命周期 | 管理方式 | 访问速度 |
| --- | --- | --- | --- | --- | --- |
| 代码段 | 可执行代码 | 只读 | 程序运行期间 | 系统管理 | 快 |
| 数据段 | 已初始化的全局变量和静态变量 | 可读写 | 程序运行期间 | 系统管理 | 快 |
| 栈 | 函数调用的上下文信息（局部变量、函数参数、返回地址等） | 可读写 | 函数调用期间 | 系统自动管理 | 快 |
| 堆 | 动态分配的内存 | 可读写 | 程序员手动控制 | 手动管理 | 相对较慢 | 