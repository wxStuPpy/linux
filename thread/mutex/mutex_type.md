### 一、检测锁（尝试锁）
#### 定义
检测锁（或称为“尝试锁”）是一种线程同步机制，线程通过它尝试非阻塞地获取锁：
- **成功获取**：若锁可用，线程立即获取锁并执行后续操作。
- **获取失败**：若锁已被其他线程占用，线程不会阻塞等待，而是立即返回（通常返回一个表示失败的状态码或布尔值）。

#### 核心特点
1. **非阻塞性**：线程在尝试获取锁失败后不会进入阻塞状态，可继续执行其他任务。这使得线程能更灵活地处理锁资源，避免长时间等待。
2. **避免死锁**：在一些复杂的锁获取场景中，如需要按特定顺序获取多个锁时，使用尝试锁可以避免线程因互相等待对方释放锁而陷入死锁。线程获取某个锁失败后，可释放已持有的其他锁，然后重新尝试或执行其他操作。
3. **应用场景**：适用于对响应时间要求较高的场景，如异步操作、非阻塞算法等，可提高系统的并发性能和响应速度。

#### 典型操作
在 C 语言的 POSIX 线程库中，使用 `pthread_mutex_trylock()` 函数来尝试获取互斥锁。

### 二、可重入锁
#### 定义
可重入锁允许同一线程多次获取同一把锁而不会引发死锁。其内部通过计数器来记录锁的获取次数：
- 线程首次获取锁时，计数器加 1，锁被标记为已占用。
- 当该线程再次获取同一把锁时，计数器继续累加，线程无需等待自己释放锁。
- 每次线程释放锁时，计数器减 1，直到计数器为 0 时，锁才真正被释放。

#### 核心特点
1. **递归安全**：支持递归函数或多层嵌套的锁调用。例如，在一个递归函数中，如果需要对共享资源进行保护，使用可重入锁可以确保线程在递归调用过程中不会因为多次获取同一把锁而产生死锁。
2. **避免自我阻塞**：同一线程在持有锁的情况下再次请求该锁时，不会被阻塞，保证了线程的正常执行流程。
3. **应用场景**：适用于包含递归算法或多层锁逻辑的代码，有助于提高代码的复用性和可维护性。

#### 典型实现
- 在 C 语言的 POSIX 线程库中，`pthread_mutex_t` 类型的互斥锁默认是非可重入的，但可以通过设置特定的属性使其成为可重入锁。
- 在 C++ 中，标准库提供了 `std::recursive_mutex` 作为可重入锁的实现。

### 三、核心区别对比
| **维度** | **检测锁（尝试锁）** | **可重入锁** |
| --- | --- | --- |
| **目的** | 非阻塞式尝试获取锁，避免线程阻塞等待和死锁 | 允许同一线程多次获取锁，支持递归调用，避免自我死锁 |
| **阻塞性** | 不阻塞，获取失败立即返回 | 对于其他线程会阻塞，同一线程重入时不阻塞 |
| **锁计数器** | 无 | 有，记录同一线程获取锁的次数 |
| **典型场景** | 异步操作、多锁顺序获取、对响应时间要求高的场景 | 递归函数、多层嵌套锁调用、代码复用性要求高的场景 |
| **关键函数** | `pthread_mutex_trylock()` 等尝试获取锁的函数 | 无特定函数，锁本身具备可重入特性 |

### 四、总结
- **检测锁**主要用于解决线程在获取锁时的阻塞问题，提高系统的并发性能和响应速度，适用于需要灵活控制锁获取逻辑的场景。
- **可重入锁**主要解决同一线程多次获取同一把锁时的死锁问题，确保递归代码的安全性和可维护性，适用于包含递归或多层锁逻辑的代码。
- 在实际开发中，可根据具体的业务需求和场景特点，灵活选择使用检测锁、可重入锁或两者结合使用。 